# -*- coding: utf-8 -*-
"""_Discrete_PID_controller_python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xv2V0KuD-zYiDDXgmr6yaewP9SW-ruwI
"""

!pip install numpy scipy matplotlib

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# --------------------------------------------------
# Simulation parameters
# --------------------------------------------------
Ts = 0.01                        # Sampling time (s)
t = np.arange(0, 2.5, Ts)       # Time vector
N = len(t)

# --------------------------------------------------
# Step Reference Input (at t = 0.5s)
# --------------------------------------------------
reference = np.where(t >= 0.5, 1.0, 0.0)

# --------------------------------------------------
# Initialize signals
# --------------------------------------------------
y = np.zeros(N)                # Plant output
u = np.zeros(N)                # Control signal
e = np.zeros(N)                # Error signal (reference - output)
integrator = np.zeros(N)       # Integrator state

# --------------------------------------------------
# Controller Gain values from the block diagram
# --------------------------------------------------
K_upper = 1.242   # Upper gain (derivative-like path)
K_lower = -1.133  # Lower gain (integrator path)

# --------------------------------------------------
# Plant Transfer Function (CT) and Discretization
# Given: 0.7725 / (0.008669s^2 + 0.1862s + 1)
# --------------------------------------------------
num = [0.7725]
den = [0.008669, 0.1862, 1]
plant_ct = signal.TransferFunction(num, den)
plant_dt = plant_ct.to_discrete(Ts, method='tustin')  # Discretize using Tustin method

b = plant_dt.num
a = plant_dt.den

# --------------------------------------------------
# Discrete-Time Simulation
# --------------------------------------------------
for n in range(2, N):
    # Error between reference and actual output
    e[n] = reference[n] - y[n-1]

    # Approximate derivative using backward difference
    d_term = (e[n-1] - e[n-2]) / Ts

    # Integrator: Accumulate error
    integrator[n] = integrator[n-1] + e[n-1] * Ts

    # Apply gains as per block diagram
    upper_path = K_upper * d_term
    lower_path = K_lower * integrator[n]

    # Total control signal
    u[n] = upper_path + lower_path

    # Plant model (difference equation)
    y[n] = (-a[1]*y[n-1] - a[2]*y[n-2] +
             b[0]*u[n] + b[1]*u[n-1] + b[2]*u[n-2])

# --------------------------------------------------
# Plotting the Output vs Reference
# --------------------------------------------------
plt.figure(figsize=(8, 5))
plt.plot(t, y, label="Output y(t)", linewidth=2)
plt.plot(t, reference, 'k--', label="Reference", linewidth=1.5)
plt.xlabel("Time (s)")
plt.ylabel("Output")
plt.title("Discrete PID Controller Simulation (Xilinx Block Style)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Sampling parameters
dt = 0.01                           # Sampling time
t = np.arange(0, 10, dt)           # Time vector

# Second-order continuous transfer function parameters
zeta = 0.4                         # Damping ratio
omega_n = 1                      # Natural frequency (rad/s)

# Continuous transfer function: G(s) = 1 / (s^2 + 2ζω_n s + ω_n^2)
num = [1]
den = [1, 2*zeta*omega_n, omega_n**2]

# Discretize using bilinear transformation (Tustin)
system_d = signal.cont2discrete((num, den), dt, method='bilinear')
b = np.ravel(system_d[0])  # Numerator coefficients
a = np.ravel(system_d[1])  # Denominator coefficients

# Pad coefficients if needed (for order match)
max_len = max(len(a), len(b))
b = np.pad(b, (0, max_len - len(b)))
a = np.pad(a, (0, max_len - len(a)))

# Input signal: Step at t=1s
u = np.zeros_like(t)
u[t >= 1.0] = 1

# Initialize output
y = np.zeros_like(t)

# Simulate using difference equation
for k in range(max_len, len(t)):
    y[k] = np.dot(b, u[k:k-max_len:-1]) - np.dot(a[1:], y[k-1:k-max_len:-1])

# Plot results
plt.figure(figsize=(10, 5))
plt.plot(t, y, label="Output of Discrete System")
plt.axhline(1, color='r', linestyle='--', label='Steady-State')
plt.title("Step Response of Discretized Second-Order System")
plt.xlabel("Time (s)")
plt.ylabel("Output")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# === PID Discrete Coefficients from Fig. 1 Equations ===
P = 1.242     # q0
q1 =  1.5  # example Ti = 50
q2 = -1.0        # Td = 0.2, Ts = 1
q0 = 1.5

# Initialize simulation parameters
n = 100
setpoint = 1.0
u = [0]         # Control output u(k)
e = [0, 0]      # Error history: e(k-1), e(k-2)
yk = [0]        # System output
Ts = 1.0        # Sample time
K_sys = 1.0     # System gain (simple model)

# === System Model (simple 1st order response) ===
def process_model(u_k, y_prev):
    alpha = 0.9  # simple inertia
    return alpha * y_prev + (1 - alpha) * u_k

# === Simulation Loop ===
for k in range(1, n):
    # Step input at k=2
    ref = setpoint if k > 2 else 0

    # Error calculation
    ek = ref - yk[-1]

    # Register Blocks (delay lines)
    e_k1 = e[-1]
    e_k2 = e[-2] if len(e) > 1 else 0
    u_k1 = u[-1]

    # Multiply blocks
    p0 = q0 * ek       # MULT1
    p1 = q1 * e_k1     # MULT2
    p2 = q2 * e_k2     # MULT3

    # Sum blocks
    s1 = p0 + p1       # SUM2
    s2 = p2 + u_k1     # SUM3
    u_k = s1 + s2      # SUM4 → u(k)

    # Apply u(k) to system
    y_k = process_model(u_k, yk[-1])

    # Update histories
    u.append(u_k)
    yk.append(y_k)
    e.append(ek)

# === Plot ===
plt.figure(figsize=(10, 5))
plt.plot(yk, label='System Output y(k)', linewidth=2)
plt.plot([setpoint]*n, '--', label='Reference (Setpoint)', color='orange')
plt.xlabel("Time step (k)")
plt.ylabel("Output")
plt.title("Discrete PID Controller (Block-based FPGA style)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# ------------------ 1. Initialize Simulation Parameters ------------------
dt = 0.01                            # Sampling time
t = np.arange(0, 10, dt)            # Time vector

# ------------------ 2. Define Transfer Function Coefficients ------------------
k = 1.025                             # Numerator gain (variable)
c = 0.08669                             # Coefficient of s^2
zeta = 0.1862/2                         # Damping ratio
omega_n = 1                        # Natural frequency (rad/s)

# ------------------ 3. Define Continuous-Time Transfer Function ------------------
num = [k]                            # Numerator: gain k
den = [c, 2 * zeta * omega_n, omega_n ** 2]  # Denominator: c*s^2 + 2ζω_ns + ω_n^2

# ------------------ 4. Discretize Transfer Function ------------------
system_d = signal.cont2discrete((num, den), dt, method='bilinear')
b = np.ravel(system_d[0])           # Discrete numerator
a = np.ravel(system_d[1])           # Discrete denominator

# Normalize to make a[0] = 1
b = b / a[0]
a = a / a[0]

# ------------------ 5. Pad Coefficients ------------------
max_len = max(len(a), len(b))
b = np.pad(b, (0, max_len - len(b)))
a = np.pad(a, (0, max_len - len(a)))

# ------------------ 6. Input Signal: Step Input ------------------
u = np.zeros_like(t)
u[t >= 1.0] = 1.0                   # Step input at t = 1 second

# ------------------ 7. Initialize Output ------------------
y = np.zeros_like(t)

# ------------------ 8. Simulate Discrete-Time System ------------------
for k in range(max_len, len(t)):
    y[k] = np.dot(b, u[k:k - max_len:-1]) - np.dot(a[1:], y[k - 1:k - max_len:-1])

# ------------------ 9. Plot the Response ------------------
plt.figure(figsize=(10, 5))
plt.plot(t, y, label="System Output", linewidth=2)
plt.axhline(1, color='r', linestyle='--', label='Step Target (1)')
plt.title(f"Step Response: Numerator={num[0]}, c={c}, ζ={zeta}, ωₙ={omega_n}")
plt.xlabel("Time (s)")
plt.ylabel("Output")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# -------------------------------
# TIME AND SIMULATION PARAMETERS
# -------------------------------
dt = 0.01                      # Time step (s)
T_total = 5.0                 # Total simulation time (s)
n_steps = int(T_total / dt)   # Number of time steps
time = np.linspace(0, T_total, n_steps)  # Time array

# -------------------------------
# REFERENCE INPUT SIGNAL
# -------------------------------
reference = np.ones(n_steps) * 1.0  # Step input

# -------------------------------
# PID PARAMETERS
# -------------------------------
Kp = 1.2      # Proportional gain
Ti = 1.0      # Integral time constant
Td = 0.02     # Derivative time constant

# -------------------------------
# COMPUTE PID COEFFICIENTS (DISCRETE-TIME)
# From parallel form:
# q0 = Kp * (1 + Td/Ti)
# q1 = -Kp * (1 - 2*Td/Ti)
# q2 = Kp * Td/Ti
# -------------------------------
q0 = Kp * (1 + Td / Ti)
q1 = -Kp * (1 - 2 * Td / Ti)
q2 = Kp * (Td / Ti)

# -------------------------------
# INITIALIZE SIGNAL ARRAYS
# -------------------------------
y = np.zeros(n_steps)        # System output
u = np.zeros(n_steps)        # Control output
e = np.zeros(n_steps)        # Error

# Previous values (register equivalents)
e_k_1 = 0.0
e_k_2 = 0.0
u_k_1 = 0.0

# -------------------------------
# SYSTEM RESPONSE FUNCTION
# First-order lag plant
# -------------------------------
def system_response(y_prev, u_curr):
    tau = 0.5  # System time constant
    return y_prev + (dt / tau) * (-y_prev + u_curr)

# -------------------------------
# MAIN PID CONTROL LOOP
# -------------------------------
for k in range(2, n_steps):
    # Current error
    e[k] = reference[k] - y[k-1]

    # PID terms
    p0 = q0 * e[k]
    p1 = q1 * e_k_1
    p2 = q2 * e_k_2

    # Combine as per parallel structure
    s1 = p0 + p1
    s2 = p2 + u_k_1
    u[k] = s1 + s2

    # Plant response
    y[k] = system_response(y[k-1], u[k])

    # Update memory values
    e_k_2 = e_k_1
    e_k_1 = e[k]
    u_k_1 = u[k]

# -------------------------------
# PLOT RESULTS
# -------------------------------
plt.figure(figsize=(10, 5))
plt.plot(time, y, label="System Output y(k)", linewidth=2, color='orange')
plt.plot(time, reference, '--', label="Reference", linewidth=1.5, color='brown')
plt.xlabel("Time (s)")
plt.ylabel("Output")
plt.title("Discrete PID Controller (Kp, Ti, Td Based Parallel Structure)")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
from collections import deque

# ------------------ 1. Simulation Time Parameters ------------------
dt = 0.01                          # Time step
T_total = 10.0                    # Total simulation time (seconds)
n_steps = int(T_total / dt)       # Number of time steps
time = np.linspace(0, T_total, n_steps)

# ------------------ 2. Reference Input ------------------
reference = np.ones(n_steps)
reference[:int(1.0 / dt)] = 0     # Step input starts at t = 1s

# ------------------ 3. Plant (2nd Order System) Parameters ------------------
k = 0.7725                         # Gain in numerator
c = 0.008669                          # Coefficient of s^2
zeta = 0.1862/2                      # Damping ratio
omega_n = 1                    # Natural frequency

# Continuous-time transfer function
num = [k]
den = [c, 2 * zeta * omega_n, omega_n ** 2]

# Discretize using bilinear transform
system_d = signal.cont2discrete((num, den), dt, method='bilinear')
b = np.ravel(system_d[0])         # Discrete numerator
a = np.ravel(system_d[1])         # Discrete denominator

# Normalize a[0] to 1
b = b / a[0]
a = a / a[0]

# Pad coefficients to same length
max_len = max(len(a), len(b))
b = np.pad(b, (0, max_len - len(b)))
a = np.pad(a, (0, max_len - len(a)))

# ------------------ 4. PID Controller Parameters ------------------
Kp = 1.242                         # Proportional gain
Ti = 1/1.133                         # Integral time constant
Td = 0.02                         # Derivative time constant

# Discrete PID coefficients (Parallel form)
q0 = Kp * (1 + Td / Ti)
q1 = -Kp * (1 - 2 * Td / Ti)
q2 = Kp * (Td / Ti)

# ------------------ 5. Initialize Arrays ------------------
y = np.zeros(n_steps)             # System output
u = np.zeros(n_steps)             # Controller output
e = np.zeros(n_steps)             # Error signal

# ------------------ 6. Initialize Registers ------------------
e_k_1 = 0.0
e_k_2 = 0.0
u_k_1 = 0.0

# Buffers for plant simulation
u_hist = deque([0.0] * len(b), maxlen=len(b))     # Input history
y_hist = deque([0.0] * (len(a)-1), maxlen=len(a)-1)  # Output history

# ------------------ 7. Plant Simulation Function ------------------
def apply_discrete_system(u_hist, y_hist, b, a):
    return np.dot(b, list(u_hist)) - np.dot(a[1:], list(y_hist))

# ------------------ 8. PID Control Loop ------------------
for k in range(2, n_steps):
    # Error
    e[k] = reference[k] - y[k-1]

    # PID computation (parallel form)
    p0 = q0 * e[k]
    p1 = q1 * e_k_1
    p2 = q2 * e_k_2

    u[k] = p0 + p1 + p2 + u_k_1

    # Plant output
    u_hist.appendleft(u[k])
    y_k = apply_discrete_system(u_hist, y_hist, b, a)
    y[k] = y_k
    y_hist.appendleft(y_k)

    # Update memory
    e_k_2 = e_k_1
    e_k_1 = e[k]
    u_k_1 = u[k]

# ------------------ 9. Plot ------------------
plt.figure(figsize=(10, 5))
plt.plot(time, y, label="System Output", linewidth=2, color='orange')
plt.plot(time, reference, '--', label="Reference Input", color='brown')
plt.xlabel("Time (s)")
plt.ylabel("Output")
plt.title("Discrete PID Controller with 2nd Order Plant")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint

# Initialize global variables for PID controller
time = 0
integral = 0
time_prev = -1e-6
e_prev = 0

# PID Controller Definition
def PID(Kp, Ki, Kd, setpoint, measurement):
    global time, integral, time_prev, e_prev
    offset = 320  # baseline output when error = 0
    e = setpoint - measurement

    # PID calculations
    P = Kp * e
    integral += Ki * e * (time - time_prev)
    D = Kd * (e - e_prev) / (time - time_prev)

    # Compute control signal
    MV = offset + P + integral + D

    # Store previous values
    e_prev = e
    time_prev = time

    return MV

# Plant/System Dynamics: Heated Tank Model
def system(t, temp, Tq):
    epsilon = 1
    tau = 4
    Tf = 300
    Q = 2
    dTdt = 1 / (tau * (1 + epsilon)) * (Tf - temp) + Q / (1 + epsilon) * (Tq - temp)
    return dTdt

# --------------------------
# 1. Uncontrolled System
# --------------------------
tspan_uncontrolled = np.linspace(0, 10, 50)
Tq_fixed = (320,)  # Constant heat input
sol_uncontrolled = odeint(system, 300, tspan_uncontrolled, args=Tq_fixed, tfirst=True)

# --------------------------
# 2. PID Controlled System
# --------------------------
# Parameters
n = 250                  # number of time steps
deltat = 0.1             # time step size
setpoint = 310           # desired temperature
Kp, Ki, Kd = 0.6, 0.2, 0.1  # PID gains

# Initialization
y0 = 300                 # initial temperature
y_sol = [y0]             # temperature results
t_sol = [0]              # time results
q_sol = [320]            # heat input over time
time_prev = 0
integral = 0

# Time loop for PID simulation
for i in range(1, n):
    time = i * deltat
    tspan = np.linspace(time_prev, time, 10)

    # PID output: Tq (manipulated variable)
    Tq = (PID(Kp, Ki, Kd, setpoint, y_sol[-1]),)

    # Simulate system
    yi = odeint(system, y_sol[-1], tspan, args=Tq, tfirst=True)

    # Store results
    t_sol.append(time)
    y_sol.append(yi[-1][0])
    q_sol.append(Tq[0])
    time_prev = time

# --------------------------
# Plotting Results
# --------------------------
plt.figure(figsize=(10, 5))
plt.plot(t_sol, y_sol, label="Controlled Temperature", linewidth=2)
plt.plot(tspan_uncontrolled, sol_uncontrolled, '--', label="Uncontrolled System", linewidth=1.5)
plt.axhline(setpoint, color='r', linestyle='--', label="Setpoint (310°C)")
plt.xlabel("Time (s)")
plt.ylabel("Temperature (°C)")
plt.title("PID Control of a Heated Tank System")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()

# Optional: Plot control signal (Tq) over time
plt.figure(figsize=(10, 4))
plt.plot(t_sol, q_sol, label="Tq (Control Signal)", color='purple')
plt.xlabel("Time (s)")
plt.ylabel("Tq Value")
plt.title("Control Signal (Tq) Over Time")
plt.grid(True)
plt.legend()
plt.tight_layout()
plt.show()